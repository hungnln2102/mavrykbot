# import_order.py (Phi√™n b·∫£n ho√†n ch·ªânh)

import logging
import re
from datetime import datetime
from collections import defaultdict
from telegram import Update, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.ext import (
    ContextTypes, ConversationHandler, CallbackQueryHandler,
    MessageHandler, filters
)

from utils import connect_to_sheet, escape_mdv2, gen_mavn_id
from column import SHEETS, PRICE_COLUMNS, IMPORT_COLUMNS
from menu import show_main_selector

logger = logging.getLogger(__name__)

# Th√™m c√°c tr·∫°ng th√°i m·ªõi cho lu·ªìng chi ti·∫øt
(STATE_ASK_NAME, STATE_PICK_CODE, STATE_NEW_CODE, STATE_PICK_SOURCE, 
 STATE_NEW_SOURCE, STATE_NHAP_THONG_TIN, STATE_NHAP_SLOT, STATE_ASK_DETAILS, 
 STATE_CONFIRM) = range(9)

# ====== C√ÅC H√ÄM TI·ªÜN √çCH ======
def _col_letter(col_idx: int) -> str:
    """Chuy·ªÉn ƒë·ªïi ch·ªâ s·ªë c·ªôt (0=A, 1=B...) th√†nh k√Ω t·ª± c·ªôt trong Google Sheet."""
    if col_idx < 0: return ""
    letter = ""
    col_idx += 1
    while col_idx > 0:
        col_idx, remainder = divmod(col_idx - 1, 26)
        letter = chr(65 + remainder) + letter
    return letter

def extract_days_from_ma_sp(ma_sp: str) -> int:
    """Tr√≠ch xu·∫•t s·ªë ng√†y t·ª´ m√£ s·∫£n ph·∫©m (v√≠ d·ª•: Netflix--12m -> 365)."""
    match = re.search(r"--(\d+)m", ma_sp.lower())
    if match:
        thang = int(match.group(1))
        return 365 if thang == 12 else thang * 30
    return 0

def tinh_ngay_het_han(ngay_bat_dau_str, so_ngay_dang_ky):
    """T√≠nh ng√†y h·∫øt h·∫°n t·ª´ ng√†y b·∫Øt ƒë·∫ßu v√† s·ªë ng√†y."""
    try:
        from dateutil.relativedelta import relativedelta
        ngay_bat_dau = datetime.strptime(ngay_bat_dau_str, "%d/%m/%Y")
        tong_ngay = int(so_ngay_dang_ky)
        so_nam, so_ngay_con_lai = divmod(tong_ngay, 365)
        so_thang, so_ngay_du = divmod(so_ngay_con_lai, 30)
        ngay_het_han = ngay_bat_dau + relativedelta(years=so_nam, months=so_thang, days=so_ngay_du - 1)
        return ngay_het_han.strftime("%d/%m/%Y")
    except (ValueError, TypeError):
        return ""

def fmt_summary(d: dict) -> str:
    """ƒê·ªãnh d·∫°ng tin nh·∫Øn t√≥m t·∫Øt th√¥ng tin nh·∫≠p h√†ng."""
    gia_nhap_str = f"{int(d.get('cost', 0)):,} ƒë" if str(d.get('cost', '')).isdigit() else d.get('cost', '')
    so_ngay_str = d.get('so_ngay', '0')
    summary = (
        "*X√°c nh·∫≠n Nh·∫≠p H√†ng*\n\n"
        f"‚àô *M√£ Phi·∫øu*: `{escape_mdv2(d.get('voucher',''))}`\n"
        f"‚àô *S·∫£n Ph·∫©m*: `{escape_mdv2(d.get('code',''))}`\n"
        f"‚àô *Ngu·ªìn*: *{escape_mdv2(d.get('source',''))}*\n"
        f"‚àô *Th√¥ng tin SP*: {escape_mdv2(d.get('thong_tin_sp',''))}\n"
        f"‚àô *Slot*: {escape_mdv2(d.get('slot',''))}\n"
        f"‚àô *Gi√° nh·∫≠p*: *{escape_mdv2(gia_nhap_str)}*\n"
        f"‚àô *S·ªë l∆∞·ª£ng*: *{escape_mdv2(str(d.get('qty','')))}*\n"
    )
    if int(so_ngay_str) > 0:
        summary += f"‚àô *Th·ªùi h·∫°n*: *{escape_mdv2(so_ngay_str)} ng√†y*\n"
    summary += f"‚àô *Ghi ch√∫*: {escape_mdv2(d.get('note',''))}"
    return summary

def get_price_data() -> list:
    """L·∫•y to√†n b·ªô d·ªØ li·ªáu t·ª´ B·∫£ng Gi√°."""
    try:
        sheet_gia = connect_to_sheet().worksheet(SHEETS["PRICE"])
        return sheet_gia.get_all_values()[1:]
    except Exception as e:
        logger.error(f"L·ªói khi t·∫£i b·∫£ng gi√°: {e}")
        return []

# ====== C√ÅC H√ÄM T·∫†O B√ÄN PH√çM (KEYBOARDS) ======
def kbd_cancel() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup([[InlineKeyboardButton("‚ùå H·ªßy", callback_data="imp_cancel")]])
def kbd_codes(cands: list[str]) -> InlineKeyboardMarkup:
    # --- THAY ƒê·ªîI LOGIC CHIA C·ªòT T·∫†I ƒê√ÇY ---
    num_products = len(cands)
    # T·ª± ƒë·ªông quy·∫øt ƒë·ªãnh s·ªë c·ªôt d·ª±a tr√™n s·ªë l∆∞·ª£ng s·∫£n ph·∫©m
    num_columns = 3 if num_products > 9 else 2

    rows = []
    row = []
    for name in cands:
        button = InlineKeyboardButton(name, callback_data=f"imp_code::{name}")
        row.append(button)
        # ƒêi·ªÅu ki·ªán chia c·ªôt ƒë∆∞·ª£c thay b·∫±ng bi·∫øn ƒë·ªông
        if len(row) == num_columns:
            rows.append(row)
            row = []
    
    # Th√™m h√†ng cu·ªëi c√πng n·∫øu c√≤n n√∫t l·∫ª
    if row:
        rows.append(row)

    # Th√™m c√°c n√∫t ch·ª©c nƒÉng
    rows.append([InlineKeyboardButton("‚úèÔ∏è Nh·∫≠p M√£ M·ªõi", callback_data="imp_new_code")])
    rows.append([InlineKeyboardButton("üîô Quay l·∫°i", callback_data="imp_cancel")])
    return InlineKeyboardMarkup(rows)
def kbd_sources(srcs: list[dict]) -> InlineKeyboardMarkup:
    rows = []
    row = []
    for source_info in srcs:
        try:
            # ƒê·ªãnh d·∫°ng l·∫°i gi√° cho ƒë·∫πp (vd: 850000 -> 850,000)
            price_val = int(re.sub(r'[^\d]', '', source_info.get('price', '0')))
            price_display = f"{price_val:,}"
        except (ValueError, TypeError):
            price_display = source_info.get('price', '0')

        source_name = source_info.get('name', 'N/A')
        label = f"{source_name} ({price_display}ƒë)"
        button = InlineKeyboardButton(label, callback_data=f"imp_src::{source_name}")
        
        row.append(button)
        if len(row) == 2:
            rows.append(row)
            row = []
    if row:
        rows.append(row)

    # Th√™m c√°c n√∫t ch·ª©c nƒÉng
    rows.append([InlineKeyboardButton("‚ûï Ngu·ªìn M·ªõi", callback_data="imp_new_src")])
    rows.append([InlineKeyboardButton("üîô Quay l·∫°i", callback_data="imp_cancel")])
    return InlineKeyboardMarkup(rows)
def kbd_confirm() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup([
        [InlineKeyboardButton("üíæ L∆∞u Phi·∫øu", callback_data="imp_save")],
        [InlineKeyboardButton("‚úèÔ∏è S·ª≠a L·∫°i", callback_data="imp_edit")],
        [InlineKeyboardButton("‚ùå H·ªßy", callback_data="imp_cancel")],
    ])

# ====== C√ÅC H√ÄM C·ª¶A LU·ªíNG CONVERSATION ======
async def start_import(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query; await query.answer()
    context.user_data.clear()
    context.user_data['imp'] = {"voucher": gen_mavn_id()}
    context.user_data['main_message_id'] = query.message.message_id
    text = (
        "*üì¶ Nh·∫≠p H√†ng*\n\n"
        f"M√£ phi·∫øu: `{escape_mdv2(context.user_data['imp']['voucher'])}`\n\n"
        "üëâ Vui l√≤ng nh·∫≠p *t√™n ho·∫∑c m√£ s·∫£n ph·∫©m* ƒë·ªÉ t√¨m ki·∫øm\\."
    )
    await query.edit_message_text(text, parse_mode="MarkdownV2", reply_markup=kbd_cancel())
    return STATE_ASK_NAME

async def on_name(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    name_query = update.message.text.strip(); await update.message.delete()
    context.user_data['imp']['name'] = name_query
    main_message_id = context.user_data.get('main_message_id')
    price_data = get_price_data()
    if not price_data:
        await context.bot.edit_message_text(chat_id=update.effective_chat.id, message_id=main_message_id, text=escape_mdv2("‚ùå L·ªói k·∫øt n·ªëi Google Sheet."), parse_mode="MarkdownV2")
        return await on_cancel(update, context)
    grouped = defaultdict(list)
    for row in price_data:
        if len(row) > PRICE_COLUMNS["TEN_SAN_PHAM"] and name_query.lower() in row[PRICE_COLUMNS["TEN_SAN_PHAM"]].strip().lower():
            grouped[row[PRICE_COLUMNS["TEN_SAN_PHAM"]].strip()].append(row)
    context.user_data['price_data_cache'] = price_data
    context.user_data['grouped_products'] = grouped
    if not grouped:
        await context.bot.edit_message_text(chat_id=update.effective_chat.id, message_id=main_message_id, text=f"‚ùóKh√¥ng t√¨m th·∫•y s·∫£n ph·∫©m ch·ª©a *{escape_mdv2(name_query)}*\\. Vui l√≤ng nh·∫≠p *M√£ s·∫£n ph·∫©m m·ªõi*:", parse_mode="MarkdownV2", reply_markup=kbd_cancel())
        return STATE_NEW_CODE
    await context.bot.edit_message_text(chat_id=update.effective_chat.id, message_id=main_message_id, text="üîé Vui l√≤ng ch·ªçn *s·∫£n ph·∫©m* ch√≠nh x√°c:", parse_mode="MarkdownV2", reply_markup=kbd_codes(list(grouped.keys())))
    return STATE_PICK_CODE

async def on_pick_code(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query; await query.answer()
    if query.data == "imp_new_code":
        await query.message.edit_text("‚ú≥Ô∏è Vui l√≤ng nh·∫≠p *m√£ s·∫£n ph·∫©m m·ªõi* \\(v√≠ d·ª•: Netflix--1m\\):", parse_mode="MarkdownV2", reply_markup=kbd_cancel())
        return STATE_NEW_CODE
    
    ma_chon = query.data.split("::", 1)[1]
    context.user_data['imp']['code'] = ma_chon
    so_ngay = extract_days_from_ma_sp(ma_chon)
    context.user_data['imp']['so_ngay'] = str(so_ngay) if so_ngay > 0 else "0"
    
    ds_sp = context.user_data.get("grouped_products", {}).get(ma_chon, [])
    context.user_data['imp']['ds_san_pham_theo_ma'] = ds_sp
    
    # L·∫•y ngu·ªìn v√† gi√°, lo·∫°i b·ªè tr√πng l·∫∑p
    sources_with_prices = {}
    for r in ds_sp:
        try:
            name = r[PRICE_COLUMNS["NGUON"]].strip()
            price_str = r[PRICE_COLUMNS["GIA_NHAP"]].strip()
            if name and name not in sources_with_prices:
                sources_with_prices[name] = price_str
        except IndexError:
            continue
    
    sources_list = [{'name': name, 'price': price} for name, price in sources_with_prices.items()]
    
    await query.message.edit_text("üß≠ Vui l√≤ng ch·ªçn *Ngu·ªìn h√†ng*:", parse_mode="MarkdownV2", reply_markup=kbd_sources(sources_list))
    return STATE_PICK_SOURCE

async def on_new_code(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    code = update.message.text.strip(); await update.message.delete()
    context.user_data['imp']['code'] = code
    so_ngay = extract_days_from_ma_sp(code)
    context.user_data['imp']['so_ngay'] = str(so_ngay) if so_ngay > 0 else "0"
    await context.bot.edit_message_text(chat_id=update.effective_chat.id, message_id=context.user_data.get('main_message_id'), text="‚ú≥Ô∏è Vui l√≤ng nh·∫≠p *t√™n ngu·ªìn h√†ng* cho s·∫£n ph·∫©m m·ªõi n√†y:", parse_mode="MarkdownV2", reply_markup=kbd_cancel())
    return STATE_NEW_SOURCE

async def on_pick_source(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query; await query.answer()
    if query.data == "imp_new_src":
        await query.message.edit_text("‚ú≥Ô∏è Vui l√≤ng nh·∫≠p *t√™n ngu·ªìn m·ªõi*:", parse_mode="MarkdownV2", reply_markup=kbd_cancel()); return STATE_NEW_SOURCE
    src = query.data.split("::", 1)[1]
    context.user_data['imp']['source'] = src
    ds = context.user_data.get('imp', {}).get("ds_san_pham_theo_ma", [])
    gia_nhap = 0
    for row in ds:
        if len(row) > PRICE_COLUMNS["NGUON"] and row[PRICE_COLUMNS["NGUON"]].strip() == src:
            try: gia_nhap = int(re.sub(r'[^\d]', '', row[PRICE_COLUMNS["GIA_NHAP"]]))
            except (ValueError, IndexError): gia_nhap = 0
            break
    context.user_data['imp']['cost'] = gia_nhap
    
    # S·ª¨A D√íNG D∆Ø·ªöI ƒê√ÇY
    await query.message.edit_text("üìù Vui l√≤ng nh·∫≠p *Th√¥ng tin s·∫£n ph·∫©m* \\(vd: t√†i kho·∫£n, m·∫≠t kh·∫©u\\):", parse_mode="MarkdownV2", reply_markup=kbd_cancel())
    
    return STATE_NHAP_THONG_TIN

async def on_new_source(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    src = update.message.text.strip(); await update.message.delete()
    context.user_data['imp']['source'] = src
    
    # S·ª¨A D√íNG D∆Ø·ªöI ƒê√ÇY
    await context.bot.edit_message_text(
        chat_id=update.effective_chat.id, 
        message_id=context.user_data.get('main_message_id'), 
        text="üìù Vui l√≤ng nh·∫≠p *Th√¥ng tin s·∫£n ph·∫©m* \\(vd: t√†i kho·∫£n, m·∫≠t kh·∫©u\\):", 
        parse_mode="MarkdownV2", 
        reply_markup=kbd_cancel()
    )
    
    return STATE_NHAP_THONG_TIN

async def nhap_thong_tin_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    context.user_data['imp']['thong_tin_sp'] = update.message.text.strip(); await update.message.delete()
    keyboard = [[InlineKeyboardButton("‚è≠Ô∏è B·ªè Qua", callback_data="imp_skip_slot")], [InlineKeyboardButton("‚ùå H·ªßy", callback_data="imp_cancel")]]
    await context.bot.edit_message_text(chat_id=update.effective_chat.id, message_id=context.user_data.get('main_message_id'), text="üß© Vui l√≤ng nh·∫≠p *Slot* (n·∫øu c√≥):", reply_markup=InlineKeyboardMarkup(keyboard), parse_mode="MarkdownV2")
    return STATE_NHAP_SLOT

async def nhap_slot_handler(update: Update, context: ContextTypes.DEFAULT_TYPE, skip:bool=False) -> int:
    query = update.callback_query
    if skip: context.user_data['imp']['slot'] = ""; await query.answer()
    else: context.user_data['imp']['slot'] = update.message.text.strip(); await update.message.delete()
    if 'cost' in context.user_data['imp']: prompt = "*S·ªë l∆∞·ª£ng*`;` *Ghi ch√∫ \\(t√πy ch·ªçn\\)*\n\n_V√≠ d·ª•_: `1; h√†ng c√≥ s·∫µn`"
    else: prompt = "*Gi√° nh·∫≠p*`;` *S·ªë l∆∞·ª£ng*`;` *Ghi ch√∫ \\(t√πy ch·ªçn\\)*\n\n_V√≠ d·ª•_: `120000; 1; h√†ng c√≥ s·∫µn`"
    await context.bot.edit_message_text(chat_id=update.effective_chat.id, message_id=context.user_data.get('main_message_id'), text=f"üßæ Nh·∫≠p chi ti·∫øt cu·ªëi c√πng:\n{prompt}", parse_mode="MarkdownV2", reply_markup=kbd_cancel())
    return STATE_ASK_DETAILS

async def on_details(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    text = update.message.text.strip(); await update.message.delete()
    parts = [p.strip() for p in text.split(";")]
    if 'cost' in context.user_data['imp']:
        context.user_data['imp']['qty'] = parts[0] if parts else "1"
        context.user_data['imp']['note'] = parts[1] if len(parts) > 1 else ""
    else:
        context.user_data['imp']['cost'] = parts[0].replace('.', '').replace(',', '') if parts else "0"
        context.user_data['imp']['qty'] = parts[1] if len(parts) > 1 else "1"
        context.user_data['imp']['note'] = parts[2] if len(parts) > 2 else ""
    summary = fmt_summary(context.user_data['imp'])
    await context.bot.edit_message_text(chat_id=update.effective_chat.id, message_id=context.user_data.get('main_message_id'), text=summary, parse_mode="MarkdownV2", reply_markup=kbd_confirm())
    return STATE_CONFIRM

async def on_confirm(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query; await query.answer()
    if query.data == "imp_edit":
        await query.message.edit_text("Vui l√≤ng nh·∫≠p l·∫°i chi ti·∫øt cu·ªëi c√πng...", parse_mode="MarkdownV2")
        return STATE_ASK_DETAILS
    if query.data == "imp_save":
        payload = context.user_data.get('imp', {}); await query.edit_message_text(text="‚è≥ ƒêang l∆∞u...")
        try:
            sheet = connect_to_sheet().worksheet(SHEETS["IMPORT"])
            next_row = len(sheet.col_values(1)) + 1
            ngay_bat_dau_str = datetime.now().strftime("%d/%m/%Y")
            so_ngay = payload.get("so_ngay", "0")
            ngay_het_han = tinh_ngay_het_han(ngay_bat_dau_str, so_ngay) if int(so_ngay) > 0 else ""
            
            row_data = [""] * len(IMPORT_COLUMNS)
            row_data[IMPORT_COLUMNS["ID_DON_HANG"]] = payload.get("voucher", "")
            row_data[IMPORT_COLUMNS["SAN_PHAM"]] = payload.get("code", "")
            row_data[IMPORT_COLUMNS["THONG_TIN_SAN_PHAM"]] = payload.get("thong_tin_sp", "")
            row_data[IMPORT_COLUMNS["SLOT"]] = payload.get("slot", "")
            row_data[IMPORT_COLUMNS["NGAY_DANG_KY"]] = ngay_bat_dau_str if int(so_ngay) > 0 else ""
            row_data[IMPORT_COLUMNS["SO_NGAY_DA_DANG_KY"]] = so_ngay if int(so_ngay) > 0 else ""
            row_data[IMPORT_COLUMNS["HET_HAN"]] = ngay_het_han
            row_data[IMPORT_COLUMNS["NGUON"]] = payload.get("source", "")
            row_data[IMPORT_COLUMNS["GIA_NHAP"]] = payload.get("cost", "")
            
            col_CL = _col_letter(IMPORT_COLUMNS["CON_LAI"])
            col_HH = _col_letter(IMPORT_COLUMNS["HET_HAN"])
            col_SN = _col_letter(IMPORT_COLUMNS["SO_NGAY_DA_DANG_KY"])
            col_GN = _col_letter(IMPORT_COLUMNS["GIA_NHAP"])
            
            if int(so_ngay) > 0:
                row_data[IMPORT_COLUMNS["CON_LAI"]] = f'=IF(ISBLANK({col_HH}{next_row}); ""; {col_HH}{next_row}-TODAY())'
                row_data[IMPORT_COLUMNS["GIA_TRI_CON_LAI"]] = f'=IFERROR({col_GN}{next_row}/{col_SN}{next_row}*{col_CL}{next_row}; 0)'
                row_data[IMPORT_COLUMNS["TINH_TRANG"]] = f'=IF({col_CL}{next_row}<=0; "H·∫øt H·∫°n"; "Ho·∫°t ƒë·ªông")'
            else:
                row_data[IMPORT_COLUMNS["TINH_TRANG"]] = "Kh√¥ng th·ªùi h·∫°n"
            row_data[IMPORT_COLUMNS["CHECK"]] = ""
            
            # Ghi d·ªØ li·ªáu v√†o sheet
            sheet.update(f"A{next_row}:{_col_letter(len(IMPORT_COLUMNS)-1)}{next_row}", [row_data], value_input_option='USER_ENTERED')
            await query.edit_message_text("‚úÖ ƒê√£ l∆∞u phi·∫øu nh·∫≠p h√†ng th√†nh c√¥ng\\.", parse_mode="MarkdownV2")
            await show_main_selector(update, context, edit=False)
        except Exception as e:
            logger.exception("L∆∞u phi·∫øu nh·∫≠p th·∫•t b·∫°i: %s", e)
            await query.edit_text(f"‚ùå L·ªói khi l∆∞u: {escape_mdv2(str(e))}", parse_mode="MarkdownV2")
        context.user_data.clear()
        return ConversationHandler.END
    return await on_cancel(update, context)

async def on_cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    if query: await query.answer(); await query.edit_message_text("‚ùå ƒê√£ h·ªßy thao t√°c.")
    context.user_data.clear()
    await show_main_selector(update, context, edit=False)
    return ConversationHandler.END

def get_import_order_conversation_handler() -> ConversationHandler:
    return ConversationHandler(
        entry_points=[CallbackQueryHandler(start_import, pattern=r'^nhap_hang$')],
        states={
            STATE_ASK_NAME:    [MessageHandler(filters.TEXT & ~filters.COMMAND, on_name)],
            STATE_PICK_CODE:   [CallbackQueryHandler(on_pick_code, pattern=r'^(imp_code::.+|imp_new_code)$')],
            STATE_NEW_CODE:    [MessageHandler(filters.TEXT & ~filters.COMMAND, on_new_code)],
            STATE_PICK_SOURCE: [CallbackQueryHandler(on_pick_source, pattern=r'^(imp_src::.+|imp_new_src)$')],
            STATE_NEW_SOURCE:  [MessageHandler(filters.TEXT & ~filters.COMMAND, on_new_source)],
            STATE_NHAP_THONG_TIN: [MessageHandler(filters.TEXT & ~filters.COMMAND, nhap_thong_tin_handler)],
            STATE_NHAP_SLOT:   [CallbackQueryHandler(lambda u,c: nhap_slot_handler(u,c,skip=True), pattern='^imp_skip_slot$'),
                                MessageHandler(filters.TEXT & ~filters.COMMAND, nhap_slot_handler)],
            STATE_ASK_DETAILS: [MessageHandler(filters.TEXT & ~filters.COMMAND, on_details)],
            STATE_CONFIRM:     [CallbackQueryHandler(on_confirm, pattern=r'^(imp_save|imp_edit|imp_cancel)$')],
        },
        fallbacks=[CallbackQueryHandler(on_cancel, pattern=r'^imp_cancel$')],
        name="import_order_conversation",
        persistent=False, allow_reentry=True,
    )